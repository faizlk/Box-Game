<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Square Dodger Mobile</title>
    <style>
        body { 
            text-align: center; 
            background: #1a1a1a; 
            color: white; 
            font-family: sans-serif; 
            margin: 0; 
            overflow: hidden; /* Prevents scrolling while playing */
            touch-action: none; /* Disables default browser gestures */
        }
        canvas { 
            background: #000; 
            display: block;
            margin: 20px auto;
            border: 2px solid #444;
            max-width: 95vw; /* Responsive width */
            max-height: 70vh;
        }
        h1 { font-size: 1.5rem; margin-top: 10px; }
    </style>
</head>
<body>
    <h1>Square Dodger</h1>
    <p>Score: <span id="score">0</span></p>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const scoreElement = document.getElementById("score");

        // Set canvas internal resolution
        canvas.width = 400;
        canvas.height = 600;

        let score = 0;
        let gameActive = true;

        const player = { x: 185, y: 530, size: 30, color: "#00b4ff" };
        const obstacles = [];

        // --- NEW: TOUCH AND MOUSE HANDLER ---
        function handleMove(e) {
            e.preventDefault();
            let clientX;
            if (e.touches) {
                clientX = e.touches[0].clientX; // Touch support
            } else {
                clientX = e.clientX; // Mouse support
            }

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width; // Account for CSS scaling
            player.x = (clientX - rect.left) * scaleX - player.size / 2;

            // Keep player inside bounds
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.size) player.x = canvas.width - player.size;
        }

        canvas.addEventListener("touchmove", handleMove, { passive: false });
        canvas.addEventListener("mousemove", handleMove);

        function createObstacle() {
            const size = Math.random() * 40 + 20;
            obstacles.push({
                x: Math.random() * (canvas.width - size),
                y: -size,
                size: size,
                speed: Math.random() * 2 + 3 + (score / 10) // Gets faster!
            });
        }

        function update() {
            if (!gameActive) return;
            for (let i = 0; i < obstacles.length; i++) {
                let o = obstacles[i];
                o.y += o.speed;
                if (player.x < o.x + o.size && player.x + player.size > o.x &&
                    player.y < o.y + o.size && player.y + player.size > o.y) {
                    gameActive = false;
                    alert("Game Over! Score: " + score);
                    location.reload();
                }
                if (o.y > canvas.height) {
                    obstacles.splice(i, 1);
                    i--;
                    score++;
                    scoreElement.innerText = score;
                }
            }
            if (Math.random() < 0.04) createObstacle();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.size, player.size);
            ctx.fillStyle = "#ff4757";
            obstacles.forEach(o => ctx.fillRect(o.x, o.y, o.size, o.size));
            update();
            requestAnimationFrame(draw);
        }
        draw();
    </script>
</body>
</html
